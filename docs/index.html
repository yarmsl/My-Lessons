<!DOCTYPE html>
<html lang="ru">

<head>
   <link href="css/style.min.css" rel="stylesheet">
   <link rel="icon" href="./favicon.ico"/>
   <link rel="manifest" href="./manifest.json"/>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width,initial-scale=1"/>
   <title>Моя Тетрадь</title>
</head>

<body>
   <div class="body__wrapper theme">
      <header class="header">
   
   <div class="header__container">
      <div class="header__logo" ></div>
      
      <h1>Быть идиотом - не коробка шоколадных конфет</h1>
   </div>
</header>
      <main class="main">

<section>
   <h2>GIT</h2>
   <p>мощная и сложная распределенная система контроля версий.</p>
   <a href="https://githowto.com/ru">Git How To</a>
<ul>
   <li>git init - Начало работы, инициализация репозитория</li>
   <li>git config - Создание конфигруации (--global user.name "Yaroslav"; --local user.email "*@m.d")</li>
   <li>git status - Проверка статуса файлов</li>
   <li>git add - Добавление файлов (-A - всех)</li>
   <li>git commit -a -m"Сообщение"</li>
   <li>git remote add origin url</li>
   <li>git branch -M main - Назначение главной ветки</li>
   <li>git push -u origin main</li>
   <li>git clone url /folder - Скачать репозиторий в папку</li>
   <li>git pull - Получить файлы с удалённого репозитория</li>
</ul>
</section>
<section>
   <h2>Консольное приложение</h2>
   <ul>
      <li>alert(title) -  показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК».</li>
      <li>prompt(title,[default]) показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null, если была нажата кнопка «Отмена» или Esc с клавиатуры.</li>
      <li>confirm(question) показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.</li>
   </ul>
   <p>запись ключа объекта, если мы задаем его кириллицей и пр. через <b>квадратные скобки</b> вместо <span>точки</span> работает корректенее</p>
</section>
<section>
   <h2>Циклы</h2>
   <a href="https://learn.javascript.ru/while-for">Циклы while и for</a>
</section>
<section>
   <h2>Функции</h2>
   <p>Подробнее про <a href="https://medium.com/nuances-of-programming/%D1%8F-%D0%BD%D0%B8%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%BD%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%87%D0%B0%D1%81%D1%82%D1%8C-%D0%BF%D0%B5%D1%80%D0%B2%D0%B0%D1%8F-3c3f02041970">замыкания</a> и <a href="https://learn.javascript.ru/closures">ещё о них</a></p>
   <p>Функции бывают:
      <ul>
         <li>Function Declaration <p>Создаётся до начала выполнения скрипта, можно вызвать перед объявлением</p></li>
         <li>Function Expression <p>Создаётся только тогда, когда доходит поток кода, можно вызвать только после объявления</p></li>
         <li>Стрелочные функции <p>Не имеют своего контекста (this)</p></li>
      </ul>
   </p>
</section>
<section>
   <h2>Методы строк и чисел</h2>
   <h3>Строк:</h3>
   <ul>
      <li>.indexOf('') <p>ищет подстроку в строке, при её отсутствии <b>возварщает -1, если находит, возварщает индекс, с которого начинается подстрока</b></p></li>
      <li>.slice(-2, )<p>возваращет подстроку из стоки с ... по ... заданный индекс, принимает <b>отрицательные значения </b><span>(тогда отсчёт идёт с конца)</span></p></li>
      <li>.substring(2,4)<p>возваращет подстроку из стоки с ... по ... заданный индекс</p></li>
      <li>.substr(2,2)<p>возваращет подстроку из стоки с ... длиной в ...</p></li>
   </ul>
   <h3>Чисел:</h3>
   <ul>
      <li>Math.round(var) <p>Округление до целых</p></li>
      <li>parseInt(var)<p>Может округлить до целого и убрать единицы измерения</p></li>
      <li>parseFloat(var)<p>Может убрать единицы измерения и оставить плавающую запятую</p></li>
   </ul>
</section>
<section>
   <h2>Колбэк функции</h2>
   <a href="https://learn.javascript.ru/callbacks">Адская пирамида колбэков</a>
</section>
<section>
   <h2>Объекты, деструктуризация объектов</h2>
   <p>оператор delete object.[] удаляет ключ - значение</p>
   <p>деструктуризация const = {key2, key2} = object.key1 <a href="https://learn.javascript.ru/destructuring#destrukturizatsiya-obekta">Подробнее</a></p>
   <p>перебор for (key in object ) { } <a href='https://learn.javascript.ru/object-for-in'>Подробнее</a></p>
   <p>метод Object.keys(object) создаёт массив с ключами первого уровня объекта</p>
   <p><a href="https://learn.javascript.ru/descriptors-getters-setters">get/set</a></p>
</section>
<section>
   <h2>Массивы и псевдомассивы</h2>
   <p>Метод перебора for (... of...) отличается от forEach, тем, что можно остановить или пропустить (break и continue)</p>
   <h3>Объекты</h3>
   <p>Создание объекта:
      <code>let obj = new Object()</code>
      <code>let obj = {}</code>
   </p>
   <h3>Массивы</h3>
   <ul>
      <li><code>arr.push()</code><span>Добавляет элемент в конец массива</span></li>
      <li><code>arr.pop()</code><span>Удаляет последний элемент из массива и возвращает его</span></li>
      <li><code>arr.shift()</code><span>Удаляет из массива первый элемент и возвращет его</span></li>
      <li><code>arr.unshift()</code><span>Добавляет элемент в начало массива</span></li>
      <li><code>arr.split(s)</code><span>Превращает строку в массив, <b>s</b> - разделитель</span></li>
      <li><code>arr.join(s)</code><span>Превращает массив в строку, <b>s</b> - разделитель</span></li>
      <li><code>delete arr[1]</code><span>Удаляет второй элемент</span></li>
      <li><code>arr.splice(index, count, elem1...)</code><span>Удалить <b>count</b> элементов, начиная с <b>index</b> и заменить на элементы <b>elem1...</b></span></li>
      <li><code>arr.slice(begin, end)</code><span>Копировать часть массива с <b>begin</b> по <b>end</b> не включая</span></li>
      <li><code>arr.sort(fn)</code><span>Сортирует масссив, если не передать функцию сравнения, сортирует элементы как строки</span></li>
      <li><code>arr.reverse()</code><span>Меняет порядок элементов на обратный</span></li>
      <li><code>arr.concat(item1...)</code><span>Создаёт новый массив, в который копируются элементы из <b>arr</b>, а также <b>item1...</b></span></li>
   </ul>
<h3>Методы перебора</h3>
<ul>
   <li><code>arr.forEach</code></li>
   <li><code>arr.map</code></li>
   <li><code>arr.every/some</code></li>
   <li><code>arr.filter</code></li>
   <li><code>arr.reduce</code></li>
</ul>
</section>
<section>
   <h2>Передача по ссылке или по значению. Spread оператор</h2>
   <p>При присваивании значений примитивных типов данных, они создают новые переменные, а при работе с Объектами создаются ссылки</p>
   <span>Создаёт новый объект из arr и arr2, также можно создать новый объект, присоединив пустой объект (Поерхностная копия)</span> <code>Object.assign({}, arr)</code>
   <code>Object.assign(arr, arr2);</code><span>Создаёт новый объект из arr и arr2, также можно создать новый объект, присоединив пустой объект</span> <code>Object.assign({}, arr)</code>
   <span>Поверхностная копия массива</span>
   <code>const newArr = oldArr.slice();</code>
   <span>Поверхностная копия, используя Spread оператор, так же работает с объекатми (ES9)</span>
   <code>const array = ['a', 'b'];</code>
   <code>const array2 = [...array];</code>
</section>
<section>
   <h2>Основы ООП, прототипно-ориентированное наследование</h2>
   <p>Старый синтаксис:</p>
   <span>joe наследует все свойстова soldier, которых у него нет</span>
   <code><pre>const soldier = {
      health: 400,
      armor: 100,
      sayHello: function() {
            console.log('Hi');
      }
};

const joe = {
      health: 100
};

joe.__proto__ = soldier;</pre></code>
<p>Новый синтаксис:</p>
<code><pre>
const joe = Object.create(soldier); <br> <span>Создаёт объект, сразу привязанный к прототипу</span>

Object.setPrototypeOf(joe, soldier);<br> <span>Устанавливает связь</span>
</pre>
</code>
</section>
<section>
   <h2>Динамическая типизация</h2>
   <h3>To String</h3>
   <ul>
      <li>String(var)</li>
      <li>Конкатенация со строкой</li>
   </ul>
   <h3>To Number</h3>
   <ul>
      <li>Number('str')</li>
      <li>Унарный плюс (+'str')</li>
      <li>parseInt()</li>
   </ul>
   <h3>To boolean</h3>
   <ul>
      <li>false: 0, '', null, undefined, NaN;</li>
      <li>true: всё остальное</li>
      <li>Boolean(var)</li>
      <li>!!var</li>
   </ul>
</section>
<section>
   <h2>Получение элементов со страницы</h2>
   <ul>
      <li><p>Получаем 1 уникальный элемент</p><code>document.getElementById('id')</code></li>
      <li><p>Получаем все элементы с данным html-тегом в html коллекцию</p><code>document.getElementsByTagName('tag')</code></li>
      <li><p>Получаем все эелементы с данным css классом в html коллекцию</p><code>document.getElementsByClassName('class')</code></li>
      <li><p>Получаем все эелементы с данным css селектором в node коллекцию <b>Доступен метод forEach</b></p><code>document.querySelectorAll('.class/#id/...')</code></li>
      <li><p>Получаем первый элемент с заданным css селектором</p><code>document.querySelector('.class/#id/...')</code></li>
   </ul>
</section>
<section>
   <h2>Действия с элементами на странице</h2>
   <p>Задать инлайн стиль элементу (наибольший вес)</p>
   <code>el.style.camelCaseCssProp = "value"</code>
   <code>el.style.cssText = 'css-prop: value; css-prop: value; ...'</code>
   <p>Создать элемент</p>
   <code>document.createElement("tag")</code>
   <p>Добавить класс</p>
   <code>el.classList.add('class')</code>
   <h3>Новые методы позиционирования элементов</h3>
   <ul>
      <li><p>Добавить элемент в начало родителя</p><code>parent.prepend(el)</code></li>
      <li><p>Добавить элемент в конец родителя</p><code>parent.append(el)</code></li>
      <li><p>Добавить элемент перед другим элементом</p><code>el_a.before(el)</code></li>
      <li><p>Добавить элемент после другого элемента</p><code></code>el_a.after(el)</li>
      <li><p>Заменить один элемент другим</p><code>el_a.replaceWith(el)</code></li>
      <li><p>Удалить элемент</p><code>el.remove()</code></li>
   </ul>
   <p>Вставляет HTML код в элемент</p>
   <code>el.innerHTML = "html код"</code>
   <p>Вставляет текст в элемент (безопасно)</p>
   <code>el.textContent = 'text'</code>
   <p>Вставляет HTML код на выбронную позицию относительно элемента</p>
   <code>el.insertAdjacentHTML('beforeend/beforebegin/afterend/afterbegin', 'html код')</code>
   <ul>
      <li>afterbegin - в начале элемента</li>
      <li>beforeend - в конце элемента</li>
      <li>beforebegin - перед элементом</li>
      <li>afterend - после элемента</li>
   </ul>
</section>
<section>
   <h2>События</h2>
   <a href="https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener">addEventListener</a>
   <h3>Способы использовать события:</h3>
   <ul>
      <li><p>Присваивать прямо в html коде (не используется в проектах)</p><code>...onclick="alert('Click')"</code></li>
      <li><p>Обрабатывать событие в скрипте (не используется в проектах (обработчики 1го элемента могут пересекаться))</p><code>el.onclick = function() {alert('Click')}</code></li>
      <li><p>Правильный способ - обрабатывать событие, используя/снимая прослушку</p><code>el.addEventListener('click'), function, {once: true} }</code></li>
   </ul>
   <p>Всплытие события происходит с самого дальнего ребёнка</p>
</section>
<section>
   <h2>Прогулка по DOM дереву</h2>
   <p>Элемент - некоторые узлы являются элементами (div, ... )</p>
   <p>Узел - все сущности в дереве - узлы (переносы строк, текст)</p>
   <h3>Способы получать элементы DOM</h3>
   <p>структуры с Element и cheldren - получают именно элементы, остальные - все узлы</p>
   <ul>
      <li><p></p><code>document.documentElement</code></li>
      <li><p></p><code>document.body.childNodes</code></li>
      <li><p></p><code>document.body.children</code></li>
      <li><p></p><code>document.body.firstChild</code></li>
      <li><p></p><code>document.body.firstElementChild</code></li>
      <li><p></p><code>document.body.lastChild</code></li>
      <li><p></p><code>document.body.lastElementChild</code></li>
      <li><p></p><code>document.querySelector('#current').parentNode</code></li>
      <li><p></p><code>document.querySelector('#current').parentElement</code></li>
      <li><p></p><code>document.querySelector('[data-current="3"]').nextElementSibling</code></li>
      <li><p></p><code>document.querySelector('[data-current="3"]').nextSibling</code></li>
      <li><p></p><code>document.querySelector('[data-current="3"]').previousSibling</code></li>
      <li><p></p><code>document.querySelector('[data-current="3"]').previousElementSibling</code></li>
   </ul>
   <p>Пример использования <span>Перебрать html коллекцию и убрать из неё текстовые узлы</span></p>
   <code>for (let node of document.body.childNodes) {
      if (node.nodeName == "#text") {
         continue;
      }
      console.log(node);
   }</code>
</section>
</main>
      <footer class="footer">
   <div class="footer__container">
      <h4>Ярослав М.</h4>
   </div>
   <script src="js/script.js"></script>
</footer>
   </div>
</body>

</html>