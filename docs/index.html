<!DOCTYPE html>
<html lang="ru">

<head>
   <link href="css/style.min.css" rel="stylesheet">
   <link rel="icon" href="./favicon.ico"/>
   <link rel="manifest" href="./manifest.json"/>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width,initial-scale=1"/>
   <title>Моя Тетрадь</title>
</head>

<body>
   <div class="body__wrapper theme">
      <header class="header">
   
   <div class="header__container">
      <div class="header__logo" ></div>
      
      <h1>Быть идиотом - не коробка шоколадных конфет</h1>
   </div>
</header>
      <main class="main">

<section>
   <h2>GIT</h2>
   <p>мощная и сложная распределенная система контроля версий.</p>
   <a href="https://githowto.com/ru">Git How To</a>
<ul>
   <li>git init - Начало работы, инициализация репозитория</li>
   <li>git config - Создание конфигруации (--global user.name "Yaroslav"; --local user.email "*@m.d")</li>
   <li>git status - Проверка статуса файлов</li>
   <li>git add - Добавление файлов (-A - всех)</li>
   <li>git commit -a -m"Сообщение"</li>
   <li>git remote add origin url</li>
   <li>git branch -M main - Назначение главной ветки</li>
   <li>git push -u origin main</li>
   <li>git clone url /folder - Скачать репозиторий в папку</li>
   <li>git pull - Получить файлы с удалённого репозитория</li>
</ul>
</section>
<section>
   <h2>Консольное приложение</h2>
   <ul>
      <li>alert(title) -  показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК».</li>
      <li>prompt(title,[default]) показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null, если была нажата кнопка «Отмена» или Esc с клавиатуры.</li>
      <li>confirm(question) показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.</li>
   </ul>
   <p>запись ключа объекта, если мы задаем его кириллицей и пр. через <b>квадратные скобки</b> вместо <span>точки</span> работает корректенее</p>
</section>
<section>
   <h2>Циклы</h2>
   <a href="https://learn.javascript.ru/while-for">Циклы while и for</a>
</section>
<section>
   <h2>Функции</h2>
   <p>Подробнее про <a href="https://medium.com/nuances-of-programming/%D1%8F-%D0%BD%D0%B8%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%BD%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%87%D0%B0%D1%81%D1%82%D1%8C-%D0%BF%D0%B5%D1%80%D0%B2%D0%B0%D1%8F-3c3f02041970">замыкания</a> и <a href="https://learn.javascript.ru/closures">ещё о них</a></p>
   <p>Функции бывают:
      <ul>
         <li>Function Declaration <p>Создаётся до начала выполнения скрипта, можно вызвать перед объявлением</p></li>
         <li>Function Expression <p>Создаётся только тогда, когда доходит поток кода, можно вызвать только после объявления</p></li>
         <li>Стрелочные функции <p>Не имеют своего контекста (this)</p></li>
      </ul>
   </p>
</section>
<section>
   <h2>Методы строк и чисел</h2>
   <h3>Строк:</h3>
   <ul>
      <li>.indexOf('') <p>ищет подстроку в строке, при её отсутствии <b>возварщает -1, если находит, возварщает индекс, с которого начинается подстрока</b></p></li>
      <li>.slice(-2, )<p>возваращет подстроку из стоки с ... по ... заданный индекс, принимает <b>отрицательные значения </b><span>(тогда отсчёт идёт с конца)</span></p></li>
      <li>.substring(2,4)<p>возваращет подстроку из стоки с ... по ... заданный индекс</p></li>
      <li>.substr(2,2)<p>возваращет подстроку из стоки с ... длиной в ...</p></li>
   </ul>
   <h3>Чисел:</h3>
   <ul>
      <li>Math.round(var) <p>Округление до целых</p></li>
      <li>parseInt(var)<p>Может округлить до целого и убрать единицы измерения</p></li>
      <li>parseFloat(var)<p>Может убрать единицы измерения и оставить плавающую запятую</p></li>
   </ul>
</section>
<section>
   <h2>Колбэк функции</h2>
   <a href="https://learn.javascript.ru/callbacks">Адская пирамида колбэков</a>
</section>
<section>
   <h2>Объекты, деструктуризация объектов</h2>
   <p>оператор delete object.[] удаляет ключ - значение</p>
   <p>деструктуризация const = {key2, key2} = object.key1 <a href="https://learn.javascript.ru/destructuring#destrukturizatsiya-obekta">Подробнее</a></p>
   <p>перебор for (key in object ) { } <a href='https://learn.javascript.ru/object-for-in'>Подробнее</a></p>
   <p>метод Object.keys(object) создаёт массив с ключами первого уровня объекта</p>
   <p><a href="https://learn.javascript.ru/descriptors-getters-setters">get/set</a></p>
</section>
<section>
   <h2>Массивы и псевдомассивы</h2>
   <p>Метод перебора for (... of...) отличается от forEach, тем, что можно остановить или пропустить (break и continue)</p>
   <h3>Объекты</h3>
   <p>Создание объекта:
      <code>let obj = new Object()</code>
      <code>let obj = {}</code>
   </p>
   <h3>Массивы</h3>
   <ul>
      <li><code>arr.push()</code><span>Добавляет элемент в конец массива</span></li>
      <li><code>arr.pop()</code><span>Удаляет последний элемент из массива и возвращает его</span></li>
      <li><code>arr.shift()</code><span>Удаляет из массива первый элемент и возвращет его</span></li>
      <li><code>arr.unshift()</code><span>Добавляет элемент в начало массива</span></li>
      <li><code>arr.split(s)</code><span>Превращает строку в массив, <b>s</b> - разделитель</span></li>
      <li><code>arr.join(s)</code><span>Превращает массив в строку, <b>s</b> - разделитель</span></li>
      <li><code>delete arr[1]</code><span>Удаляет второй элемент</span></li>
      <li><code>arr.splice(index, count, elem1...)</code><span>Удалить <b>count</b> элементов, начиная с <b>index</b> и заменить на элементы <b>elem1...</b></span></li>
      <li><code>arr.slice(begin, end)</code><span>Копировать часть массива с <b>begin</b> по <b>end</b> не включая</span></li>
      <li><code>arr.sort(fn)</code><span>Сортирует масссив, если не передать функцию сравнения, сортирует элементы как строки</span></li>
      <li><code>arr.reverse()</code><span>Меняет порядок элементов на обратный</span></li>
      <li><code>arr.concat(item1...)</code><span>Создаёт новый массив, в который копируются элементы из <b>arr</b>, а также <b>item1...</b></span></li>
   </ul>
<h3>Методы перебора</h3>
<ul>
   <li><code>arr.forEach</code></li>
   <li><code>arr.map</code></li>
   <li><code>arr.every/some</code></li>
   <li><code>arr.filter</code></li>
   <li><code>arr.reduce</code></li>
</ul>
</section>
<section>
   <h2>Передача по ссылке или по значению. Spread оператор</h2>
   <p>При присваивании значений примитивных типов данных, они создают новые переменные, а при работе с Объектами создаются ссылки</p>
   <span>Создаёт новый объект из arr и arr2, также можно создать новый объект, присоединив пустой объект (Поерхностная копия)</span> <code>Object.assign({}, arr)</code>
   <code>Object.assign(arr, arr2);</code><span>Создаёт новый объект из arr и arr2, также можно создать новый объект, присоединив пустой объект</span> <code>Object.assign({}, arr)</code>
   <span>Поверхностная копия массива</span>
   <code>const newArr = oldArr.slice();</code>
   <span>Поверхностная копия, используя Spread оператор, так же работает с объекатми (ES9)</span>
   <code>const array = ['a', 'b'];</code>
   <code>const array2 = [...array];</code>
</section>
<section>
   <h2>Основы ООП, прототипно-ориентированное наследование</h2>
   <p>Старый синтаксис:</p>
   <span>joe наследует все свойстова soldier, которых у него нет</span>
   <code><pre>const soldier = {
      health: 400,
      armor: 100,
      sayHello: function() {
            console.log('Hi');
      }
};

const joe = {
      health: 100
};

joe.__proto__ = soldier;</pre></code>
<p>Новый синтаксис:</p>
<code><pre>
const joe = Object.create(soldier); <br> <span>Создаёт объект, сразу привязанный к прототипу</span>

Object.setPrototypeOf(joe, soldier);<br> <span>Устанавливает связь</span>
</pre>
</code>
</section>
<section>
   <h2>Динамическая типизация</h2>
   <h3>To String</h3>
   <ul>
      <li>String(var)</li>
      <li>Конкатенация со строкой</li>
   </ul>
   <h3>To Number</h3>
   <ul>
      <li>Number('str')</li>
      <li>Унарный плюс (+'str')</li>
      <li>parseInt()</li>
   </ul>
   <h3>To boolean</h3>
   <ul>
      <li>false: 0, '', null, undefined, NaN;</li>
      <li>true: всё остальное</li>
      <li>Boolean(var)</li>
      <li>!!var</li>
   </ul>
</section>
<section>
   <h2>Получение элементов со страницы</h2>
   <ul>
      <li><p>Получаем 1 уникальный элемент</p><code>document.getElementById('id')</code></li>
      <li><p>Получаем все элементы с данным html-тегом в html коллекцию</p><code>document.getElementsByTagName('tag')</code></li>
      <li><p>Получаем все эелементы с данным css классом в html коллекцию</p><code>document.getElementsByClassName('class')</code></li>
      <li><p>Получаем все эелементы с данным css селектором в node коллекцию <b>Доступен метод forEach</b></p><code>document.querySelectorAll('.class/#id/...')</code></li>
      <li><p>Получаем первый элемент с заданным css селектором</p><code>document.querySelector('.class/#id/...')</code></li>
   </ul>
</section>
<section>
   <h2>Действия с элементами на странице</h2>
   <p>Задать инлайн стиль элементу (наибольший вес)</p>
   <code>el.style.camelCaseCssProp = "value"</code>
   <code>el.style.cssText = 'css-prop: value; css-prop: value; ...'</code>
   <p>Создать элемент</p>
   <code>document.createElement("tag")</code>
   <p>Добавить класс</p>
   <code>el.classList.add('class')</code>
   <h3>Новые методы позиционирования элементов</h3>
   <ul>
      <li><p>Добавить элемент в начало родителя</p><code>parent.prepend(el)</code></li>
      <li><p>Добавить элемент в конец родителя</p><code>parent.append(el)</code></li>
      <li><p>Добавить элемент перед другим элементом</p><code>el_a.before(el)</code></li>
      <li><p>Добавить элемент после другого элемента</p><code></code>el_a.after(el)</li>
      <li><p>Заменить один элемент другим</p><code>el_a.replaceWith(el)</code></li>
      <li><p>Удалить элемент</p><code>el.remove()</code></li>
   </ul>
   <p>Вставляет HTML код в элемент</p>
   <code>el.innerHTML = "html код"</code>
   <p>Вставляет текст в элемент (безопасно)</p>
   <code>el.textContent = 'text'</code>
   <p>Вставляет HTML код на выбронную позицию относительно элемента</p>
   <code>el.insertAdjacentHTML('beforeend/beforebegin/afterend/afterbegin', 'html код')</code>
   <ul>
      <li>afterbegin - в начале элемента</li>
      <li>beforeend - в конце элемента</li>
      <li>beforebegin - перед элементом</li>
      <li>afterend - после элемента</li>
   </ul>
</section>
<section>
   <h2>События</h2>
   <a href="https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener">addEventListener</a>
   <h3>Способы использовать события:</h3>
   <ul>
      <li><p>Присваивать прямо в html коде (не используется в проектах)</p><code>...onclick="alert('Click')"</code></li>
      <li><p>Обрабатывать событие в скрипте (не используется в проектах (обработчики 1го элемента могут пересекаться))</p><code>el.onclick = function() {alert('Click')}</code></li>
      <li><p>Правильный способ - обрабатывать событие, используя/снимая прослушку</p><code>el.addEventListener('click'), function, {once: true} }</code></li>
   </ul>
   <p>Всплытие события происходит с самого дальнего ребёнка</p>
</section>
<section>
   <h2>Прогулка по DOM дереву</h2>
   <p>Элемент - некоторые узлы являются элементами (div, ... )</p>
   <p>Узел - все сущности в дереве - узлы (переносы строк, текст)</p>
   <h3>Способы получать элементы DOM</h3>
   <p>структуры с Element и cheldren - получают именно элементы, остальные - все узлы</p>
   <ul>
      <li><p></p><code>document.documentElement</code></li>
      <li><p></p><code>document.body.childNodes</code></li>
      <li><p></p><code>document.body.children</code></li>
      <li><p></p><code>document.body.firstChild</code></li>
      <li><p></p><code>document.body.firstElementChild</code></li>
      <li><p></p><code>document.body.lastChild</code></li>
      <li><p></p><code>document.body.lastElementChild</code></li>
      <li><p></p><code>document.querySelector('#current').parentNode</code></li>
      <li><p></p><code>document.querySelector('#current').parentElement</code></li>
      <li><p></p><code>document.querySelector('[data-current="3"]').nextElementSibling</code></li>
      <li><p></p><code>document.querySelector('[data-current="3"]').nextSibling</code></li>
      <li><p></p><code>document.querySelector('[data-current="3"]').previousSibling</code></li>
      <li><p></p><code>document.querySelector('[data-current="3"]').previousElementSibling</code></li>
   </ul>
   <p>Пример использования <span>Перебрать html коллекцию и убрать из неё текстовые узлы</span></p>
   <code><pre>for (let node of document.body.childNodes) {
      if (node.nodeName == "#text") {
         continue;
      }
      console.log(node);
   }</pre></code>
</section>
<section>
   <h2>События на мобильных устройствах</h2>
   <ul>
      <li><p></p><code>touchstart</code></li>
      <li><p></p><code>touchmove</code></li>
      <li><p></p><code>touchend</code></li>
      <li><p></p><code>touchenter</code></li>
      <li><p></p><code>touchleave</code></li>
      <li><p></p><code>touchcancel</code></li>
   </ul>
   <h3>Cвойства event</h3>
   <ul>
      <li><p>Количество одновременных касаний</p><code>touches</code></li>
      <li><p>Количество одновременных касаний на определенном элементе</p><code>targetTouches</code></li>
      <li><p>Список пальцев, учавствовавших в текущем событии</p><code>changedTouches</code></li>
   </ul>
   <a href="http://youon.ru/%D0%90%D0%BD%D0%B4%D1%80%D0%BE%D0%B8%D0%B4/%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0/touch-sobytiya-na-javascript-multitach-realizatsiya">Подробнее</a>
   <a href="https://habr.com/ru/company/sibirix/blog/227175/">Ещё</a>
</section>
<section>
   <h2>Async, defer</h2>
   <p>async - такой скрипт загружается немедленно, независимо от остальных</p>
   <code>script async src="script.js"</script></code>
   <p>defer - такой скрипт можно подключать не только в конце, он дождется загрузки дом, потом сработает. если скриптов несколько, сработают в порядке очереди</p>
   <code>script defer src="script.js"</script></code>
</section>
<section>
   <h2>ClassList</h2>
   <a href='https://developer.mozilla.org/ru/docs/Web/API/Element/classList'>Element.classList</a>
   <a href='https://developer.mozilla.org/ru/docs/Web/API/Element/matches'>Element.matches()</a>
   <a href='https://learn.javascript.ru/event-delegation'>Делегирование событий</a>
   <a href='https://stasonmars.ru/javascript/kak-rabotaet-delegirovanie-sobityi-v-javascript/'>Делегирование событий</a>
<p>Делегирование позволяет использовать лишь одну прослушку, что экономит ресурсы, так же оно правильно отрабатывает с динамически созданными элементами, так как прослушивается их родитель. Пример:</p>
<code><pre>
   wrapper = document.querySelector('.btn-block');
   wrapper.addEventListener('click', (e) => {
      if (e.target && e.target.matches('button.red')) {
         console.log('HELL!');
      }
   });
</pre></code>
</section>
<section>
   <h2>ES6 особенности</h2>
   <ul>
      <li>В объявлении функции можно задавать параметр по умолчанию: <code>function fName(param = 0) {}</code></code></li>
      <a href="https://alligator.io/js/object-property-shorthand-es6/">Сокращенная запись объектов</a>
   </ul>
</section>
<section>
   <h2>setTimeout, setInterval</h2>
   <p>рекурсивный вызов setTimeout отрабатывает лучше, чем setInterval (setInterval не ждёт после выполнения функции) Пример:</p>
   <code><pre>let id = setTimeout(function log() {
      console.log('recursion setTimeout');
      id = setTimeout(log, 500);
   }, 500);</pre></code>
   <p>Пример использования setInterval и clearInterval</p>
   <code><pre>const timeInterval = setInterval(function, 1000);
      if (smth) {
         clearInterval(timeInterval);               
      }
   </pre></code>
</section>
<section>
   <h2>Работа с датами</h2>
   <a href='https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date'>Документация</a>
   <a href='https://learn.javascript.ru/date'>Статья</a>
   <p>Создание объекта с датой: <code>const date = new Date()</code><span>Создаётся текущая дата.</span> В скобки можно передать аргумент, допустим значение <code>input type="date"</code></p>
</section>
<section>
   <h2>Параметры документа, окна и работа с ними</h2>
   <img src="./img/metric-all.webp" />
   <code>box-sizing: border-box;</code><span> Паддинги входят в длину/ширину элемента</span>
   <h3>Метрика элементов</h3>
   <ul>
      <li>
         <p>Получения значений js позиционирования</p>
         <code>console.log(el.getBoundingClientRect().prop);</code>
      </li>
      <li>
         <p>Получение уже просчитанных стилей</p>
         <code><pre>
            const style = window.getComputedStyle(el,{псевдокласс});
            console.log(style.prop);
         </pre></code>
      </li>
   </ul>
   <h3>Метрика документа и окна</h3>
   <p>Пример:</p>
   <code>console.log(document.documentElement.scrollTop)</code>
   <code>window.scrollBy(x, y)</code>
   <code>window.scrollTo(x, y)</code>
</section>
<section>
   <h2>Функции конструкторы</h2>
   <a href="https://learn.javascript.ru/constructor-new">Подробнее</a>
</section>
<section>
   <h2>Контекст вызова. This</h2>
   <a href='https://tproger.ru/translations/javascript-this-keyword/'>Подробнее</a>
   <p>Особенности:</p>
   <ul>
      <li>Обычная функция: this = window, но если use strict - undefined</li>
      <li>Контекст у методов объекта - сам объект</li>
      <li>this в конструкторах и классах - это новый экземпляр объекта</li>
      <li>Ручна привязка this: call, apply, bind</li>
   </ul>
   <p>Методы присвоения контекста -> функции, .call и .apply разлчаются синтаксисом передачи аргументов</p>
   <code><pre>
   function sayName(surname) {
      console.log(this);
      console.log(this.name + surname);
   }
   
   const user = {
      name: 'John'
   };
   
   sayName.<b>call</b>(user, 'Constantine');
   sayName.<b>apply</b>(user, ['Wick']);
</pre></code>
<p>.bind создёт новую функцию</p>
<code><pre>
function count(num) {
   return this*num;
}

const double = count<b>.bind(2)</b>;

console.log(double(223));
console.log(double(22322));
</pre></code>
</section>
<section>
   <h2>ES6 Классы</h2>
   <a href='https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes'>Документация по классам</a>
   <a href='http://jsraccoon.ru/es6-classes'>Статья по классам</a>
   <p>Класс именуется с большой буквы, содержит <b>constructor</b>, в который передаются свойства. 
      Если мы хотим переиспользовать класс в другом классе нужно указать <b>extends</b>, чтобы использовать 
      свойства этого класса, в constructor нужно указать <b>super(props) - он идёт первым</b>
   </p>
   <code><pre>
      class Rectangle {
         <b>constructor</b>(h, w) {
            this.height = h;
            this.width = w;
         }
         calcArea() {
            return this.width * this.height;
         }
      }
      
      class ColoredRectangleWithText <b>extends</b> Rectangle {
         constructor (h, w, text, bgColor) {
            <b>super</b>(h, w);
            this.text = text;
            this.bgColor = bgColor;
         }
         showMyProps() {
            console.log(`Текст: ${this.text}, цвет: ${this.bgColor}`);
         }
      }
      
      const square = new Rectangle(10, 50);
      
      const shape = new ColoredRectangleWithText(12, 20, 'Я сферка', '#000000');
      
      console.log(square.calcArea());
      
      shape.showMyProps();
      console.log(shape.calcArea());
   </pre></code>
</section>
<section>
   <h2>Rest оператор и параметры по умолчанию (ES6)</h2>
   <a href='https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Rest_parameters'>Документация</a>
   <a href='https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Default_parameters'>Параметры по умолчанию</a>
   <p>Оператор ...rest <span>Называть можно как угодно</span></p>
   <code><pre>
      const log = function(a,b, <b>...rest</b>) {
         console.log();
      }
   </pre></code>
   <p>Значени по умолчанию можно передавать прямо в параметрах объявления функции</p>
   <code><pre>
      function calcOrDouble(number, basis <b>= 2</b>) {
         console.log(number * basis);
      }
   </pre></code>
</section>
<section>
   <h2>JSON формат передачи данных</h2>
   <a href="https://ru.wikipedia.org/wiki/JSON">Подробнее</a>
   <a href="https://ru.wikipedia.org/wiki/HTTP">HTTP пртокол передачи данных</a>
   <a href="https://medium.com/@stasonmars/%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%B2-javascript-d25c261a7aff">Копирование объектов в JS</a>
   <ul>
      <li>JSON.stringify(obj)</li>
      <li>JSON.parse(JSON)</li>
   </ul>
   <p>Глубинное клонирование объекта:</p>
   <code>const clone = JSON.parse(JSON.stringify(obj));</code>
</section>
<section>
   <h2>AJAX и общение с сервером</h2>
   <h3>XMLHttpRequest</h3>
   <p><a href="https://developer.mozilla.org/ru/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a>
   <a href="https://developer.mozilla.org/ru/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest">Использование XMLHttpRequest</a>
   <a href="https://developer.mozilla.org/ru/docs/Web/API/XMLHttpRequest/readyState">XMLHttpRequest.readyState</a></p>
   <h3>FormData</h3>
   <p><a href="https://developer.mozilla.org/ru/docs/Web/API/FormData/Using_FormData_Objects">Использование Объектов FormData</a>
   <a href="https://ilikekillnerds.com/2017/09/convert-formdata-json-object/">Из FormData в JSON</a></p>
   <h3>HTTP</h3>
   <p><a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8_HTTP">Заголовки HTTP</a>
   <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP">Список кодов состояния HTTP</a></p>
</section>
<section>
   <h2>
      Promise ES6
   </h2>
   <a href="https://learn.javascript.ru/promise-basics">Подробнее</a>
   <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise">Ещё</a>
   <p><code>const req = new Promise((resolve, reject) => {async code})</code></p>
   <ul>
      <li><code>.then</code><p>Действия при положительном исходе</p></li>
      <li><code>.catch</code><p>Действия при отрицательном</p></li>
      <li><code>.finally</code><p>Действия при любом исходе (допустим очистка формы)</p></li>
   </ul>
   <p>Методы Promise</p>
   <ul>
      <li>
         <p>All выполняет действие, когда все промисы завершены</p>
         <code>Promise.all([func1, func2, ...]).then(() => {func})</code>
      </li>
      <li>
         <p>Race выполняет действие, когда один из промисов (первый) завершён</p>
         <code>Promise.race([func1, func2, ...]).then(() => {func})</code>
      </li>
   </ul>
</section>
<section>
   <h2>Fetch API</h2>
   <a href="https://developer.mozilla.org/ru/docs/Web/API/Fetch_API/Using_Fetch">Подробнее</a>
   <p>Отлавливание ошибок:</p>
   <code><pre>
      if (!result.ok) {
         throw new Error(`Couldt fetch ${url}, status: ${result.status}`);
      }
   </pre></code>
</section>
<section>
   <h2>Методы перебора массивов</h2>
   <a href='https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map'>map</a>
   <a href='https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/filter'>filter</a>
   <a href='https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce'>reduce</a>
   <a href='https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries'>Object.entries()</a>
   <p>Переборы every/some возвращают true/false если каждый или хотя бы один элемент массива подходит заданному условию соответственно</p>
   <p>Reduce простым языком:</p>
   <code><pre>
      let arr = [1, 6, 9, 2];
      arr.reduce((sum, current) => sum + current, [startValue])
   </pre></code>
</section>
<section>
   <h2>npm пакеты</h2>
   <p>Флаги:</p>
   <ul>
      <li>-g или --global - установить глобально</li>
      <li>-D или --save--dev - пакет для разработки</li>
   </ul>
</section>
<section>
   <h2>Async/Await ES8</h2>
   <p>Пример использования <span>в функции, которая использует асинхронный код (промисы) позволяет дождаться выполнения кода</span> :</p>
<code><pre>      
   const postData = <b>async</b> (url, data) => { // объявление асинхронной функции
   const result = <b>await</b> fetch(url, { // дождаться, пока выполнится POST запрос
      method: 'POST',
      headers: {
         'Content-type': 'application/json'
      },
      body: data
   });
   return <b>await</b> result.json(); // Дождаться пока ответ конвертируется в JS объект
};
</pre></code>
</section>
</main>
      <footer class="footer">
   <div class="footer__container">
      <h4>Ярослав М.</h4>
   </div>
   <script src="js/script.js"></script>
</footer>
   </div>
</body>

</html>