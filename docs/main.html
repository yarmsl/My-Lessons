<main class="main">

<section>
   <h2>GIT</h2>
   <p>мощная и сложная распределенная система контроля версий.</p>
   <a href="https://githowto.com/ru">Git How To</a>
<ul>
   <li>git init - Начало работы, инициализация репозитория</li>
   <li>git config - Создание конфигруации (--global user.name "Yaroslav"; --local user.email "*@m.d")</li>
   <li>git status - Проверка статуса файлов</li>
   <li>git add - Добавление файлов (-A - всех)</li>
   <li>git commit -a -m"Сообщение"</li>
   <li>git remote add origin url</li>
   <li>git branch -M main - Назначение главной ветки</li>
   <li>git push -u origin main</li>
   <li>git clone url /folder - Скачать репозиторий в папку</li>
   <li>git pull - Получить файлы с удалённого репозитория</li>
</ul>
</section>
<section>
   <h2>Консольное приложение</h2>
   <ul>
      <li>alert(title) -  показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК».</li>
      <li>prompt(title,[default]) показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null, если была нажата кнопка «Отмена» или Esc с клавиатуры.</li>
      <li>confirm(question) показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.</li>
   </ul>
   <p>запись ключа объекта, если мы задаем его кириллицей и пр. через <b>квадратные скобки</b> вместо <span>точки</span> работает корректенее</p>
</section>
<section>
   <h2>Циклы</h2>
   <a href="https://learn.javascript.ru/while-for">Циклы while и for</a>
</section>
<section>
   <h2>Функции</h2>
   <p>Подробнее про <a href="https://medium.com/nuances-of-programming/%D1%8F-%D0%BD%D0%B8%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%BD%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%87%D0%B0%D1%81%D1%82%D1%8C-%D0%BF%D0%B5%D1%80%D0%B2%D0%B0%D1%8F-3c3f02041970">замыкания</a> и <a href="https://learn.javascript.ru/closures">ещё о них</a></p>
   <p>Функции бывают:
      <ul>
         <li>Function Declaration <p>Создаётся до начала выполнения скрипта, можно вызвать перед объявлением</p></li>
         <li>Function Expression <p>Создаётся только тогда, когда доходит поток кода, можно вызвать только после объявления</p></li>
         <li>Стрелочные функции <p>Не имеют своего контекста (this)</p></li>
      </ul>
   </p>
</section>
<section>
   <h2>Методы строк и чисел</h2>
   <h3>Строк:</h3>
   <ul>
      <li>.indexOf('') <p>ищет подстроку в строке, при её отсутствии <b>возварщает -1, если находит, возварщает индекс, с которого начинается подстрока</b></p></li>
      <li>.slice(-2, )<p>возваращет подстроку из стоки с ... по ... заданный индекс, принимает <b>отрицательные значения </b><span>(тогда отсчёт идёт с конца)</span></p></li>
      <li>.substring(2,4)<p>возваращет подстроку из стоки с ... по ... заданный индекс</p></li>
      <li>.substr(2,2)<p>возваращет подстроку из стоки с ... длиной в ...</p></li>
   </ul>
   <h3>Чисел:</h3>
   <ul>
      <li>Math.round(var) <p>Округление до целых</p></li>
      <li>parseInt(var)<p>Может округлить до целого и убрать единицы измерения</p></li>
      <li>parseFloat(var)<p>Может убрать единицы измерения и оставить плавающую запятую</p></li>
   </ul>
</section>
<section>
   <h2>Колбэк функции</h2>
   <a href="https://learn.javascript.ru/callbacks">Адская пирамида колбэков</a>
</section>
<section>
   <h2>Объекты, деструктуризация объектов</h2>
   <p>оператор delete object.[] удаляет ключ - значение</p>
   <p>деструктуризация const = {key2, key2} = object.key1 <a href="https://learn.javascript.ru/destructuring#destrukturizatsiya-obekta">Подробнее</a></p>
   <p>перебор for (key in object ) { } <a href='https://learn.javascript.ru/object-for-in'>Подробнее</a></p>
   <p>метод Object.keys(object) создаёт массив с ключами первого уровня объекта</p>
   <p><a href="https://learn.javascript.ru/descriptors-getters-setters">get/set</a></p>
</section>
<section>
   <h2>Массивы и псевдомассивы</h2>
   <p>Метод перебора for (... of...) отличается от forEach, тем, что можно остановить или пропустить (break и continue)</p>
   <h3>Объекты</h3>
   <p>Создание объекта:
      <code>let obj = new Object()</code>
      <code>let obj = {}</code>
   </p>
   <h3>Массивы</h3>
   <ul>
      <li><code>arr.push()</code><span>Добавляет элемент в конец массива</span></li>
      <li><code>arr.pop()</code><span>Удаляет последний элемент из массива и возвращает его</span></li>
      <li><code>arr.shift()</code><span>Пдаляет из массива первый элемент и возвращет его</span></li>
      <li><code>arr.unshift()</code><span>Побавляет элемент в начало массива</span></li>
      <li><code>arr.split(s)</code><span>Превращает строку в массив, <b>s</b> - разделитель</span></li>
      <li><code>arr.join(s)</code><span>Превращает массив в строку, <b>s</b> - разделитель</span></li>
      <li><code>delete arr[1]</code><span>Удаляет второй элемент</span></li>
      <li><code>arr.splice(index, count, elem1...)</code><span>Удалить <b>count</b> элементов, начиная с <b>index</b> и заменить на элементы <b>elem1...</b></span></li>
      <li><code>arr.slice(begin, end)</code><span>Копировать часть массива с <b>begin</b> по <b>end</b> не включая</span></li>
      <li><code>arr.sort(fn)</code><span>Сортирует масссив, если не передать функцию сравнения, сортирует элементы как строки</span></li>
      <li><code>arr.reverse()</code><span>Меняет порядок элементов на обратный</span></li>
      <li><code>arr.concat(item1...)</code><span>Создаёт новый массив, в который копируются элементы из <b>arr</b>, а также <b>item1...</b></span></li>
   </ul>
<h3>Методы перебора</h3>
<ul>
   <li><code>arr.forEach</code></li>
   <li><code>arr.map</code></li>
   <li><code>arr.every/some</code></li>
   <li><code>arr.filter</code></li>
   <li><code>arr.reduce</code></li>
</ul>
</section>
<section>
   <h2>Передача по ссылке или по значению. Spread оператор</h2>
   <p>При присваивании значений примитивных типов данных, они создают новые переменные, а при работе с Объектами создаются ссылки</p>
   <span>Создаёт новый объект из arr и arr2, также можно создать новый объект, присоединив пустой объект (Поерхностная копия)</span> <code>Object.assign({}, arr)</code>
   <code>Object.assign(arr, arr2);</code><span>Создаёт новый объект из arr и arr2, также можно создать новый объект, присоединив пустой объект</span> <code>Object.assign({}, arr)</code>
   <span>Поверхностная копия массива</span>
   <code>const newArr = oldArr.slice();</code>
   <span>Поверхностная копия, используя Spread оператор, так же работает с объекатми (ES9)</span>
   <code>const array = ['a', 'b'];</code>
   <code>const array2 = [...array];</code>
</section>
</main>